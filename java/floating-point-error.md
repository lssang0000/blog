(정리중 ... )

## 숫자형 변수 타입
- 정수형 
byte    8   -128 ~127
short   16  -32768~32767
int     32  -2147483648~21483647 
long    64  -9223372036854775808~9223372036854775807 

- 실수형
float   32  1.40239846e-45f ~3.40282347e+38f 
double  64  4.94065645841246544e-324~1.79769313486231570e+308 

## 실수형 표현 방법
- 고정 소수점(Fixed Point) 방식
  - 구성
    - 1bit : 부호
    - 15bit : 정수를 표현
    - 16bit : 소수를 표현
  ```
  [1bit 부호][    15bit 정수부    ][     16bit 소수부     ]
  ```
  - 장점
    - 단순하고 쉽다.
  - 단점
    - 너무 단순해서 간단한 성적처리도 못할 정도로 효용성이 없다.
- IEEE 754 부동 소수점(Floating Point) 방식
  - 원리
    - 실수를 (가수)×(밑수)^(지수)로 표현 
    - 자세한 내용은 [부동 소수점 표현 원리](https://ko.wikipedia.org/wiki/부동소수점#원리)를 참고
  - 구성
    - 1bit : 부호
    - 8bit : 지수부
    - 23it : 가수부
  ```
  [1bit 부호][  8bit 지수부  ][        23bit 가수부        ]
  ```
  - 장점
    - 표현할 수 있는 수의 범위가 굉장히 넓어진다.
  - 단점
    - 부동 소수점으로 표현한 수가 실수를 정확히 표현하지 못한다.

## 부동 소수점의 부적확성 원인

[부동 소수점 표현 정확도 문제](https://ko.wikipedia.org/wiki/부동소수점#정확도_문제) 참고

EEE-754 부동소수점 표준에 의해 정수, 소수 등과 같은 숫자가 2진으로 저장되기 때문에 나타납니다. 예를 들어 1,2,3과 같은 정수는 2진수로 표현이 가능합니다. 하지만 1/7(0.142857142857... ), 0.1과 같은 소수(무한, 순환, 유한)들은 2진수로 표현할 방법이 없기 때문입니다. 0.142857...을 소수점 몇 번째 자리 아래에서 반올림을 하여도 그것은 반올림을 한 값이지 0.142857... 과 같은 값은 아닙니다. 컴퓨터는 그 값과 가장 근사한 값을 반환하는 것이고, 이때 부동소수점의 부정확성이 나타납니다.      

## BigDecimal

## Reference
https://ko.wikipedia.org/wiki/부동소수점
https://ssoco.tistory.com/25

## [**Back to Blog Home**](../README.md)